/**
 * @license
 * Copyright Google Inc. All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */
import {AUTO_STYLE, AnimateTimings, AnimationAnimateChildMetadata, AnimationAnimateMetadata, AnimationGroupMetadata, AnimationKeyframesSequenceMetadata, AnimationMetadata, AnimationMetadataType, AnimationQueryMetadata, AnimationReferenceMetadata, AnimationSequenceMetadata, AnimationStaggerMetadata, AnimationStateMetadata, AnimationStyleMetadata, AnimationTransitionMetadata, AnimationTriggerMetadata, AnimationWaitMetadata, style, ɵStyleData} from '@angular/animations';

import {getOrSetAsInMap} from '../render/shared';
import {ENTER_SELECTOR, LEAVE_SELECTOR, NG_ANIMATING_SELECTOR, NG_TRIGGER_SELECTOR, copyObj, copyStyles, normalizeAnimationEntry, resolveTimingValue, validateStyleLocals} from '../util';

import {AnimationAnimateAst, AnimationAnimateChildAst, AnimationAst, AnimationGroupAst, AnimationKeyframesSequenceAst, AnimationQueryAst, AnimationReferenceAst, AnimationSequenceAst, AnimationStaggerAst, AnimationStateAst, AnimationStyleAst, AnimationTimingAst, AnimationTransitionAst, AnimationTriggerAst, AnimationWaitAst, DynamicAnimationTimingAst} from './animation_ast';
import {AnimationDslVisitor, visitAnimationNode} from './animation_dsl_visitor';
import {parseTransitionExpr} from './animation_transition_expr';



/*
 * [Validation]
 * The visitor code below will traverse the animation AST generated by the animation verb functions
 * (the output is a tree of objects) and attempt to perform a series of validations on the data. The
 * following corner-cases will be validated:
 *
 * 1. Overlap of animations
 * Given that a CSS property cannot be animated in more than one place at the same time, it's
 * important that this behaviour is detected and validated. The way in which this occurs is that
 * each time a style property is examined, a string-map containing the property will be updated with
 * the start and end times for when the property is used within an animation step.
 *
 * If there are two or more parallel animations that are currently running (these are invoked by the
 * group()) on the same element then the validator will throw an error. Since the start/end timing
 * values are collected for each property then if the current animation step is animating the same
 * property and its timing values fall anywhere into the window of time that the property is
 * currently being animated within then this is what causes an error.
 *
 * 2. Timing values
 * The validator will validate to see if a timing value of `duration delay easing` or
 * `durationNumber` is valid or not.
 *
 * (note that upon validation the code below will replace the timing data with an object containing
 * {duration,delay,easing}.
 *
 * 3. Offset Validation
 * Each of the style() calls are allowed to have an offset value when placed inside of keyframes().
 * Offsets within keyframes() are considered valid when:
 *
 *   - No offsets are used at all
 *   - Each style() entry contains an offset value
 *   - Each offset is between 0 and 1
 *   - Each offset is greater to or equal than the previous one
 *
 * Otherwise an error will be thrown.
 */
export function buildAnimationAst(
    metadata: AnimationMetadata | AnimationMetadata[], errors: any[]): AnimationAst {
  return new AnimationAstBuilderVisitor().build(metadata, errors);
}

const LEAVE_TOKEN = ':leave';
const LEAVE_TOKEN_REGEX = new RegExp(LEAVE_TOKEN, 'g');
const ENTER_TOKEN = ':enter';
const ENTER_TOKEN_REGEX = new RegExp(ENTER_TOKEN, 'g');

export class AnimationAstBuilderVisitor implements AnimationDslVisitor {
  build(metadata: AnimationMetadata|AnimationMetadata[], errors: any[]): AnimationAst {
    const context = new AnimationAstBuilderContext(errors);
    return visitAnimationNode(this, normalizeAnimationEntry(metadata), context) as AnimationAst;
  }

  visitTrigger(metadata: AnimationTriggerMetadata, context: AnimationAstBuilderContext):
      AnimationTriggerAst {
    let queryCount = context.queryCount = 0;
    let depCount = context.depCount = 0;
    const states: AnimationStateAst[] = [];
    const transitions: AnimationTransitionAst[] = [];
    metadata.definitions.forEach(def => {
      if (def.type == AnimationMetadataType.State) {
        const stateDef = def as AnimationStateMetadata;
        const name = stateDef.name;
        name.split(/\s*,\s*/).forEach(n => {
          stateDef.name = n;
          states.push(this.visitState(stateDef, context));
        });
        stateDef.name = name;
      } else if (def.type == AnimationMetadataType.Transition) {
        const transition = this.visitTransition(def as AnimationTransitionMetadata, context);
        queryCount += transition.queryCount;
        depCount += transition.depCount;
        transitions.push(transition);
      } else {
        context.errors.push(
            'only state() and transition() definitions can sit inside of a trigger()');
      }
    });
    const ast = new AnimationTriggerAst(metadata.name, states, transitions);
    ast.queryCount = queryCount;
    ast.depCount = depCount;
    return ast;
  }

  visitState(metadata: AnimationStateMetadata, context: AnimationAstBuilderContext):
      AnimationStateAst {
    return new AnimationStateAst(metadata.name, this.visitStyle(metadata.styles, context));
  }

  visitTransition(metadata: AnimationTransitionMetadata, context: AnimationAstBuilderContext):
      AnimationTransitionAst {
    context.queryCount = 0;
    context.depCount = 0;
    const entry = visitAnimationNode(this, normalizeAnimationEntry(metadata.animation), context);
    const matchers = parseTransitionExpr(metadata.expr, context.errors);
    const ast = new AnimationTransitionAst(matchers, entry, normalizeLocals(metadata.locals));
    ast.queryCount = context.queryCount;
    ast.depCount = context.depCount;
    return ast;
  }

  visitSequence(metadata: AnimationSequenceMetadata, context: AnimationAstBuilderContext):
      AnimationSequenceAst {
    return new AnimationSequenceAst(metadata.steps.map(s => visitAnimationNode(this, s, context)));
  }

  visitGroup(metadata: AnimationGroupMetadata, context: AnimationAstBuilderContext):
      AnimationGroupAst {
    const currentTime = context.currentTime;
    let furthestTime = 0;
    const steps = metadata.steps.map(step => {
      context.currentTime = currentTime;
      const ast = visitAnimationNode(this, step, context);
      furthestTime = Math.max(furthestTime, context.currentTime);
      return ast;
    });
    context.currentTime = furthestTime;
    return new AnimationGroupAst(steps);
  }

  visitAnimate(metadata: AnimationAnimateMetadata, context: AnimationAstBuilderContext):
      AnimationAnimateAst {
    const timingAst = constructTimingAst(metadata.timings, context.errors);
    context.currentAnimateTimings = timingAst;

    let styles: AnimationStyleAst|AnimationKeyframesSequenceAst = null;
    let styleMetadata: AnimationMetadata = metadata.styles ? metadata.styles : style({});
    if (styleMetadata.type == AnimationMetadataType.KeyframeSequence) {
      styles =
          this.visitKeyframeSequence(styleMetadata as AnimationKeyframesSequenceMetadata, context);
    } else {
      let styleMetadata = metadata.styles as AnimationStyleMetadata;
      let isEmpty = false;
      if (!styleMetadata) {
        isEmpty = true;
        const newStyleData: {[prop: string]: string | number} = {};
        if (timingAst.easing) {
          newStyleData['easing'] = timingAst.easing;
        }
        styleMetadata = style(newStyleData);
      }
      context.currentTime += timingAst.duration + timingAst.delay;
      const styleAst = this.visitStyle(styleMetadata, context);
      styleAst.isEmptyStep = isEmpty;
      styles = styleAst;
    }

    context.currentAnimateTimings = null;
    return new AnimationAnimateAst(timingAst, styles);
  }

  visitStyle(metadata: AnimationStyleMetadata, context: AnimationAstBuilderContext):
      AnimationStyleAst {
    const ast = this._makeStyleAst(metadata, context);
    this._validateStyleAst(ast, context);
    return ast;
  }

  private _makeStyleAst(metadata: AnimationStyleMetadata, context: AnimationAstBuilderContext):
      AnimationStyleAst {
    const styles: (ɵStyleData | string)[] = [];
    if (Array.isArray(metadata.styles)) {
      (metadata.styles as(ɵStyleData | string)[]).forEach(styleTuple => {
        if (typeof styleTuple == 'string') {
          if (styleTuple == AUTO_STYLE) {
            styles.push(styleTuple as string);
          } else {
            context.errors.push(`The provided style string value ${styleTuple} is not allowed.`);
          }
        } else {
          styles.push(styleTuple as ɵStyleData);
        }
      })
    } else {
      styles.push(metadata.styles);
    }

    let collectedEasing: string = null;
    styles.forEach(styleData => {
      if (isObject(styleData)) {
        const styleMap = styleData as ɵStyleData;
        const easing = styleMap['easing'];
        if (easing) {
          collectedEasing = easing as string;
          delete styleMap['easing'];
        }
      }
    });
    return new AnimationStyleAst(styles, collectedEasing, metadata.offset);
  }

  private _validateStyleAst(ast: AnimationStyleAst, context: AnimationAstBuilderContext): void {
    const timings = context.currentAnimateTimings;
    let endTime = context.currentTime;
    let startTime = context.currentTime;
    if (timings && startTime > 0) {
      startTime -= timings.duration + timings.delay;
    }

    ast.styles.forEach(tuple => {
      if (typeof tuple == 'string') return;

      Object.keys(tuple).forEach(prop => {
        const collectedStyles = context.collectedStyles[context.currentQuerySelector];
        const collectedEntry = collectedStyles[prop];
        let updateCollectedStyle = true;
        if (collectedEntry) {
          if (startTime != endTime && startTime >= collectedEntry.startTime &&
              endTime <= collectedEntry.endTime) {
            context.errors.push(
                `The CSS property "${prop}" that exists between the times of "${collectedEntry.startTime}ms" and "${collectedEntry.endTime}ms" is also being animated in a parallel animation between the times of "${startTime}ms" and "${endTime}ms"`);
            updateCollectedStyle = false;
          }

          // we always choose the smaller start time value since we
          // want to have a record of the entire animation window where
          // the style property is being animated in between
          startTime = collectedEntry.startTime;
        }

        if (updateCollectedStyle) {
          collectedStyles[prop] = {startTime, endTime};
        }

        if (context.locals) {
          validateStyleLocals(tuple[prop], context.locals, context.errors);
        }
      });
    });
  }

  visitKeyframeSequence(
      metadata: AnimationKeyframesSequenceMetadata,
      context: AnimationAstBuilderContext): AnimationKeyframesSequenceAst {
    if (!context.currentAnimateTimings) {
      context.errors.push(`keyframes() must be placed inside of a call to animate()`);
      return;
    }

    const MAX_KEYFRAME_OFFSET = 1;

    let totalKeyframesWithOffsets = 0;
    const offsets: number[] = [];
    let offsetsOutOfOrder = false;
    let keyframesOutOfRange = false;
    let previousOffset: number = 0;

    const keyframes: AnimationStyleAst[] = metadata.steps.map(styles => {
      const style = this._makeStyleAst(styles, context);
      let offsetVal: number = style.offset != null ? style.offset : consumeOffset(style.styles);
      let offset: number = 0;
      if (offsetVal != null) {
        totalKeyframesWithOffsets++;
        offset = style.offset = offsetVal;
      }
      keyframesOutOfRange = keyframesOutOfRange || offset < 0 || offset > 1;
      offsetsOutOfOrder = offsetsOutOfOrder || offset < previousOffset;
      previousOffset = offset;
      offsets.push(offset);
      return style;
    });

    if (keyframesOutOfRange) {
      context.errors.push(`Please ensure that all keyframe offsets are between 0 and 1`);
    }

    if (offsetsOutOfOrder) {
      context.errors.push(`Please ensure that all keyframe offsets are in order`);
    }

    const length = metadata.steps.length;
    let generatedOffset = 0;
    if (totalKeyframesWithOffsets > 0 && totalKeyframesWithOffsets < length) {
      context.errors.push(`Not all style() steps within the declared keyframes() contain offsets`);
    } else if (totalKeyframesWithOffsets == 0) {
      generatedOffset = MAX_KEYFRAME_OFFSET / (length - 1);
    }

    const limit = length - 1;
    const currentTime = context.currentTime;
    const animateDuration = context.currentAnimateTimings.duration;
    keyframes.forEach((kf, i) => {
      const offset = generatedOffset > 0 ? (i == limit ? 1 : (generatedOffset * i)) : offsets[i];
      const durationUpToThisFrame = offset * animateDuration;
      context.currentTime =
          currentTime + context.currentAnimateTimings.delay + durationUpToThisFrame;
      context.currentAnimateTimings.duration = durationUpToThisFrame;
      this._validateStyleAst(kf, context);
      kf.offset = offset;
    });

    return new AnimationKeyframesSequenceAst(keyframes);
  }

  visitReference(metadata: AnimationReferenceMetadata, context: AnimationAstBuilderContext):
      AnimationReferenceAst {
    const entry = visitAnimationNode(this, normalizeAnimationEntry(metadata.animation), context);
    return new AnimationReferenceAst(entry, normalizeLocals(metadata.locals));
  }

  visitAnimateChild(metadata: AnimationAnimateChildMetadata, context: AnimationAstBuilderContext):
      AnimationAnimateChildAst {
    let animationArg: AnimationReferenceMetadata = null;
    let timings: AnimateTimings = null;
    let locals: {[key: string]: any} = null;
    const args = metadata.args;
    switch (countArgs(args)) {
      case 0:
        // animateChild()
        context.depCount++;
        break;
      case 1:
        // animateChild(string|definition|number)
        const arg = args[0];
        if (typeof arg == 'string' || arg >= 0) {
          // animateChild(string|number)
          context.depCount++;
          timings = resolveTimingValue(arg as string | number, context.errors);
        } else if ((arg as AnimationMetadata).type == AnimationMetadataType.Definition) {
          // animateChild(definition)
          animationArg = arg as AnimationReferenceMetadata;
        }
        break;
      case 2:
        animationArg = args[0] as any;
        if (animationArg['type']) {
          // animateChild(definition, locals)
          animationArg = args[0] as AnimationReferenceMetadata;
          locals = normalizeLocals(args[1] as{[key: string]: any});
        } else {
          // animateChild(string|number, definition)
          timings = resolveTimingValue(args[0] as string | number, context.errors);
          animationArg = args[1] as AnimationReferenceMetadata;
        }
        break;
      default:
        // animateChild(string|number, definition, locals)
        timings = resolveTimingValue(args[0] as string | number, context.errors);
        animationArg = args[1] as AnimationReferenceMetadata;
        locals = normalizeLocals(args[2] as{[key: string]: any});
        break;
    }
    const animation = animationArg ? this.visitReference(animationArg, context) : null;
    return new AnimationAnimateChildAst(timings, animation, locals);
  }

  visitQuery(metadata: AnimationQueryMetadata, context: AnimationAstBuilderContext):
      AnimationQueryAst {
    const parentSelector = context.currentQuerySelector;

    context.queryCount++;
    context.currentQuery = metadata;
    const [selector, includeSelf] = normalizeSelector(metadata.selector);
    context.currentQuerySelector =
        parentSelector.length ? (parentSelector + ' ' + selector) : selector;
    getOrSetAsInMap(context.collectedStyles, context.currentQuerySelector, {});

    const entry = visitAnimationNode(this, normalizeAnimationEntry(metadata.animation), context);
    context.currentQuery = null;
    context.currentQuerySelector = parentSelector;
    return new AnimationQueryAst(selector, metadata.multi, includeSelf, entry);
  }

  visitStagger(metadata: AnimationStaggerMetadata, context: AnimationAstBuilderContext):
      AnimationStaggerAst {
    if (!context.currentQuery || !context.currentQuery.multi) {
      context.errors.push(`stagger() can only be used inside of queryAll()`);
    }
    let timings: AnimateTimings;
    let animation: AnimationAst;
    switch (countArgs(metadata.args)) {
      case 1:
        // stagger(animation)
        timings = { duration: 0, delay: 0, easing: 'full' } as AnimateTimings;
        animation = visitAnimationNode(this, normalizeAnimationEntry(metadata.args[0]), context);
        break;
      default:
        // stagger(timing, animation)
        timings = resolveTimingValue(metadata.args[0] as string, context.errors, true);
        animation = visitAnimationNode(this, normalizeAnimationEntry(metadata.args[1]), context);
        break;
    }
    return new AnimationStaggerAst(timings, animation);
  }

  visitWait(metadata: AnimationWaitMetadata, context: AnimationAstBuilderContext):
      AnimationWaitAst {
    const timings = resolveTimingValue(metadata.delay, context.errors);
    if (timings.duration < 0) {
      context.errors.push('Negative wait delays are not supported');
    }
    if (timings.duration && timings.delay) {
      context.errors.push('Wait delays can only support a single timing value');
    }
    if (timings.easing) {
      context.errors.push('Wait delays cannot support easing values');
    }

    const animation = metadata.animation ?
        visitAnimationNode(this, normalizeAnimationEntry(metadata.animation), context) :
        null;
    return new AnimationWaitAst(timings.duration, animation);
  }
}

function normalizeSelector(selector: string): [string, boolean] {
  const hasAmpersand = selector.split(/\s*,\s*/).find(token => token == '&') ? true : false;
  if (hasAmpersand) {
    selector = selector.replace(/\s*&\s*,?/g, '');
  }

  selector = selector.replace(ENTER_TOKEN_REGEX, ENTER_SELECTOR)
                 .replace(LEAVE_TOKEN_REGEX, LEAVE_SELECTOR)
                 .replace(/@\*/g, NG_TRIGGER_SELECTOR)
                 .replace(/@\w+/g, match => NG_TRIGGER_SELECTOR + '-' + match.substr(1))
                 .replace(/:animating/g, NG_ANIMATING_SELECTOR);

  return [selector, hasAmpersand];
}


function normalizeLocals(obj: {[key: string]: any}): {[key: string]: any} {
  return obj ? copyObj(obj) : null;
}

function countArgs(args: any[]): number {
  return args.reduce((count, arg) => (arg != null ? 1 : 0) + count, 0);
}

export type StyleTimeTuple = {
  startTime: number; endTime: number;
};

export class AnimationAstBuilderContext {
  public queryCount: number = 0;
  public depCount: number = 0;
  public currentTransition: AnimationTransitionMetadata;
  public currentQuery: AnimationQueryMetadata;
  public currentQuerySelector: string;
  public currentAnimateTimings: AnimationTimingAst;
  public currentTime: number = 0;
  public collectedStyles: {[selectorName: string]: {[propName: string]: StyleTimeTuple}} = {};
  public locals: {[varName: string]: string | number | boolean} = null;
  constructor(public errors: any[]) {
    // this is for the rootElement's selector
    const ROOT_SELECTOR = '';
    this.currentQuerySelector = ROOT_SELECTOR;
    this.collectedStyles[ROOT_SELECTOR] = {};
  }
}

function consumeOffset(styles: ɵStyleData | string | (ɵStyleData | string)[]): number {
  let offset: number = null;
  if (typeof styles == 'string') return offset;

  if (Array.isArray(styles)) {
    styles.forEach(styleTuple => {
      if (isObject(styleTuple) && styleTuple.hasOwnProperty('offset')) {
        const obj = styleTuple as ɵStyleData;
        offset = parseFloat(obj['offset'] as string);
        delete obj['offset'];
      }
    });
  } else if (isObject(styles) && styles.hasOwnProperty('offset')) {
    const obj = styles as ɵStyleData;
    offset = parseFloat(obj['offset'] as string);
    delete obj['offset'];
  }
  return offset;
}

function isObject(value: any): boolean {
  return !Array.isArray(value) && typeof value == 'object';
}

function constructTimingAst(value: string | number | AnimateTimings, errors: any[]) {
  let timings: AnimateTimings = null;
  if (value.hasOwnProperty('duration')) {
    timings = value as AnimateTimings;
  } else if (typeof value == 'number') {
    const duration = resolveTimingValue(value as number, errors).duration;
    return new AnimationTimingAst(value as number, 0, '');
  }

  const strValue = value as string;
  const isDynamic = strValue.split(/\s+/).some(v => v.charAt(0) == '$');
  if (isDynamic) {
    return new DynamicAnimationTimingAst(strValue);
  }

  timings = timings || resolveTimingValue(strValue, errors);
  return new AnimationTimingAst(timings.duration, timings.delay, timings.easing);
}
